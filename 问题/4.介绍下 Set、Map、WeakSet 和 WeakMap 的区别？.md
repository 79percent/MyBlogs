## 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

### Set
Set是一个类数组的结构,最大的特点就是每一项都不是重复的，因此可以用来数组去重操作。
Set内部判断是否相等， 应该是类似与 === 的精确比较。
但是特别的一点是：NaN在Set中是相同的（可能是用isNaN判断？？）

### WeakSet
与Set不同的是，它的每一项只能是对象，而且它是弱引用，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

tip: 垃圾回收机制：依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。

### Map
JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。

Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。

### WeakMap
WeakMap与Map的区别有两点。

首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
其次，WeakMap的***键名***所指向的对象，不计入垃圾回收机制。（注意是键名）

先看一个普通对象的引用
```javascript
let obj1 = {};
let obj2 = {};
let arr = [obj1,obj2];// [{}, {}]
obj1 = null;
console.log(arr);// 此时arr还是等于 [{}, {}], 也就是说obj1原先的对象值还是在内存当中，没有被垃圾处理机制清除掉，因为obj1值的引用计数是1
// 必须手动删除引用，
arr [0] = null;
arr [1] = null;
// 上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。
```

如果换成WeakMap引用对象
```javascript
let obj1 = {};
let obj2 = {};
let wkMap = new WeakMap();
wkMap.set(obj1, 1);
wkMap.set(obj2, 2); 
/**
  WeakMap {{…} => 2, {…} => 1}
    [[Entries]]
    0: {Object => 2}
      key: {}
      value: 2
    1: {Object => 1}
      key: {}
      value: 1
 */
obj1 = null;
// WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。
// 此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。
// 虽然打印出来wkMap还是和上面的一样
// 但是实际上，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。
```


